<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Documentation Niralakka - Authentification</title>
  <link href="assets/style.css" rel="stylesheet">
</head>

<body>

  <header>
    <h1>Documentation Niralakka</h1>
  </header>

  <main>

    <section>
      <h2>Authentification</h2>
      <p>
        Le projet utilise un syst√®me d'authentification bas√© sur <strong>React Context</strong> et
        <strong>TanStack Query</strong>.  
        Ce m√©canisme permet de g√©rer :
      </p>
      <ul>
        <li>la connexion de l'utilisateur,</li>
        <li>la r√©cup√©ration de ses informations,</li>
        <li>la d√©connexion et la mise √† jour de l'interface.</li>
      </ul>
    </section>

    <section>
      <h2>1. AuthContext</h2>
      <p>
        Un Context React se r√©initialise si l'application est rafra√Æchie : l'√©tat <code>isLoggedIn</code> et les donn√©es utilisateur sont donc perdus.
Pour √©viter cela, nous utilisons un <code>useEffect</code> qui s'ex√©cute au montage de l'application. Il appelle <code>refetchUser</code> pour v√©rifier la session via le backend et ainsi restaurer l'√©tat d'authentification et les informations de l'utilisateur automatiquement.
        <br/><code>AuthContext</code> est le point central de l'authentification.  
        Il conserve :
      </p>
      <ul>
        <li>l'√©tat de connexion (<code>isLoggedIn</code>),</li>
        <li>les informations de l'utilisateur (<code>user</code>),</li>
        <li>un √©tat de chargement et d'erreur,</li>
        <li>et une m√©thode <code>logOut</code> pour g√©rer la d√©connexion.</li>
      </ul>
      <p>
        Au d√©marrage ou lors d'un rafra√Æchissement de page, le contexte r√©ex√©cute une requ√™te
        <code>getCurrentUser</code> pour revalider la session gr√¢ce au cookie envoy√© par le backend.
      </p>
    </section>

    <section>
      <h2>2. Connexion avec useLogin</h2>
      <p>
        La connexion se fait via le hook <code>useLogin</code>.  
        Celui-ci utilise <strong>useMutation</strong> (TanStack Query) pour envoyer les identifiants au backend.  
        En cas de succ√®s :
      </p>
      <ul>
        <li>le backend retourne un <strong>cookie s√©curis√©</strong> contenant le token,</li>
        <li>le contexte met √† jour <code>isLoggedIn</code> √† <code>true</code>,</li>
        <li>et les donn√©es utilisateur sont rafra√Æchies automatiquement avec <code>fetchUser</code>.</li>
      </ul>
      <div class="tip">
        üí° <strong>Astuce :</strong> gr√¢ce aux cookies HttpOnly, le front n'a pas besoin de g√©rer manuellement le stockage du token.
      </div>
    </section>

    <section>
      <h2>3. Gestion des cookies</h2>
      <p>
        Le backend envoie un token sous forme de <strong>cookie HttpOnly</strong>.  
        Cela apporte plusieurs avantages :
      </p>
      <ul>
        <li>le cookie n'est pas accessible via <code>document.cookie</code>,</li>
        <li>il est transmis automatiquement avec chaque requ√™te HTTP, assurant que seul un utilisateur v√©rifi√© puisse effectuer des requ√™tes</li>
        <li>il am√©liore la s√©curit√© (√©vite le stockage manuel dans <code>localStorage</code> ou <code>sessionStorage</code>).</li>
      </ul>
    </section>

    <section>
      <h2>4. Cycle d'authentification</h2>
      <ol>
        <li>L'utilisateur envoie ses identifiants via <code>useLogin</code>.</li>
        <li>Le backend v√©rifie et renvoie un cookie s√©curis√© avec le token.</li>
        <li><code>AuthContext</code> appelle <code>getCurrentUser</code> pour r√©cup√©rer les infos utilisateur.</li>
        <li>L'application met √† jour son interface (profil, acc√®s aux routes prot√©g√©es, etc.).</li>
        <li>En cas de d√©connexion, <code>logOut</code> vide le cache et remet l'√©tat √† <code>false</code>. Le backend supprime le token des cookies.</li>
      </ol>
    </section>

    

  </main>

  <footer>
    &copy; 2025 Niralakka - Documentation Authentification
  </footer>

</body>

</html>
